+++
author = "Masataka Kashiwagi"
title = "ネストしたリストの更新処理"
date = "2020-09-12"
description = "リストを複製して作成し，それを更新したい場合"
tags = [
    "python",
    "tips",
]
showLicense = false
+++

## リストの更新処理でハマってしまった失敗
今回は，初期化したリストを更新した際にハマってしまった失敗があるので，備忘録として残しておきます．  
pythonで決まった形のリストを予め作成しておきたい場合に，以下のようにすることがあると思います．
```python
shape you want: [[0, 0], [0, 0], [0, 0]] # 要素が2つあるリストが3つ
>>> list1 = [[0] * 2] * 3
>>> list1
[[0, 0], [0, 0], [0, 0]]
```
そして，上記リストを何かしらの値で更新したい場合を考えます．
今回だと，[0][0]の要素を更新するとします．

```python
>>> list1[0][0] = 3.5
>>> list1
[[3.5, 0], [3.5, 0], [3.5, 0]]
```

結果は，各リストの0番目の要素が全て更新されています．
この原因は，list1 = [[0] * 2] * 3と書くと，要素のリストが全て同じオブジェクトになってしまうからです．

```python
>>> id(list1[0]) == id(list1[1]) == id(list1[2])
True
```

これにより，どこかの要素を変更すると全て変わってしまうということになります．

## 多次元配列の初期化時の注意
上記の結果を回避するためにはリスト内包表記を使うと解決することができます．
先程の例の場合，以下のように書くといいです．

```python
>>> list2 = [[0] * 2 for i in range(3)]
>>> list2
[[0, 0], [0, 0], [0, 0]]
```

内包表記を使うと，リストはそれぞれ異なるオブジェクトとして扱われます．

```python
>>> id(list2[0]) == id(list2[1]) == id(list2[2])
False
```

ですので，[0][0]の要素を更新すると，意図した部分だけが更新され問題ありません．

```python
>>> list2[0][0] = 3.5
>>> list2
[[3.5, 0], [0, 0], [0, 0]]
```

リストを初期化する際はこれらに注意しておかないと，本来の意図とは違う動きになってしまいます．

## 参考
[Pythonのリスト（配列）を任意の値・要素数で初期化](https://note.nkmk.me/python-list-initialize/)